# 플로이드-워셜(Floyd–Warshall) 알고리즘

## 🚀 핵심 아이디어
- **모든 정점 쌍 (i, j)** 사이의 최단 경로를 구한다.
- 중간에 거쳐가는 정점들을 하나씩 고려하면서 더 짧은 경로가 있는지 갱신한다.
- 다이나믹 프로그래밍(DP) 원리를 사용한다.

---

## 📘 점화식
- `dist[i][j]`: 정점 i에서 j로 가는 현재까지 알려진 최단 거리
- 어떤 정점 `k`를 거쳐갈 수 있다고 했을 때:
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

---

## 📑 알고리즘 절차
1. 인접 행렬 형태로 그래프를 준비한다.
   - 자기 자신 → 자기 자신: `0`
   - 연결 안 되어 있으면: `INF`
   - 간선이 있으면: 가중치로 초기화
2. 3중 for문으로 모든 경로를 갱신한다.

```java
for (int k = 1; k <= n; k++) {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
        }
    }
}
```
---

##시간 복잡도
- O(N³)
- N이 최대 100~500일 때 주로 사용한다.

---

## 🎯 특징
- 장점
  - 모든 쌍 최단 경로를 한 번에 구할 수 있음
  - 구현이 간단함

- 단점
  - O(N³)라서 N이 크면 느림
  - 음수 가중치는 가능하지만 음수 사이클이 있으면 올바른 결과 X
