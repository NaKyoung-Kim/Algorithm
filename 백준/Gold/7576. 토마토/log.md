## 풀이방향
1. `tomato[i][j] == 1` 일때, [i][j]에서부터 `BFS` 탐색
  -> 서로 다른 지점에서 `BFS가` 시작되었을 때, 같은 토마토 칸에 여러 개의 숫자가 들어가야 하는 경우가 발생한다.
   ex) `tomato[3][4] = 0` 으로 시작.
   [1][1]에서 시작된 BFS는 [3][4]에 5를 넣으려 하고, [4][4]에서 시작한 BFS는 2를 넣으려고 하는 경우 등.

   고려해야 할 점들이 복잡해 보여서 1번 -> 2번으로 수정했다.

   
2. `deque 2개` 이용: `queue` / `next_queue`
  전체 `tomato를` 탐색해 값이 `1`인 칸들을 `queue`에 넣고, `queue`가 빌 때까지 `bfs` 수행.
  `bfs`: tomato에서 값이 `0`인 곳을 탐색한 후 `1`로 값을 변경해줌.
       이후 현재 위치 기준으로 상하좌우를 한 번씩만 탐색해 값 변경이 가능한 위치를 `next_queue`에 넣어 반환
  `return`받은 `next_queue`를 `queue`로 변경해 `bfs`를 계속 수행. `bfs`를 수행할 때마다 `day 값`을 `1`씩 증가시킴

  답안 제출했을 때 틀린 답안이라고 뜨고, 반례를 찾지 못해서 다른 방법으로 수정했다. (2번 -> 3번)


3. deque 하나 이용.
   전체 `tomato`를 탐색해 값이 1인 칸들을 `queue`에 넣고, `queue`가 빌 때까지 `bfs` 수행.
   현재 위치 기준으로 상하좌우를 탐색해 값이 0인 칸은 `현재 칸의 값 + 1` 을 넣어줌.
   `bfs` 종료 후 `tomato 전체 중 가장 큰 값 - 1` 을 출력. (0일차에 max값이 1. 가장 큰 값이 N인 날은 N-1일차다.)


## 3안 오답원인
1. 25Line에서 max_day가 1인 경우를 고려하지 않았음
